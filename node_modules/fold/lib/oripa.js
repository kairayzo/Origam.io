//#TODO: match spec (no frame_designer, no frame_reference, fix cw -> ccw)
//#TODO: oripa folded state format
var DOMParser, convert, filter, oripa, ref, x, y;

if (typeof DOMParser === "undefined" || DOMParser === null) {
  DOMParser = require('@xmldom/xmldom').DOMParser;
}

//XMLSerializer = require('@xmldom/xmldom').XMLSerializer unless XMLSerializer?
//DOMImplementation = require('@xmldom/xmldom').DOMImplementation unless DOMImplementation?
convert = require('./convert');

filter = require('./filter');

oripa = exports;

//# Based on src/oripa/geom/OriLine.java
oripa.type2fold = {
  0: 'F', //# TYPE_NONE = flat
  1: 'B', //# TYPE_CUT = boundary 
  2: 'M', //# TYPE_RIDGE = mountain
  3: 'V' //# TYPE_VALLEY = valley
};

oripa.fold2type = {};

ref = oripa.type2fold;
for (x in ref) {
  y = ref[x];
  oripa.fold2type[y] = x;
}

oripa.fold2type_default = 0;

oripa.prop_xml2fold = {
  'editorName': 'frame_author',
  'originalAuthorName': 'frame_designer',
  'reference': 'frame_reference',
  'title': 'frame_title',
  'memo': 'frame_description',
  'paperSize': null,
  'mainVersion': null,
  'subVersion': null
};

//oripa.prop_fold2xml = {}
//for x, y of oripa.prop_xml2fold
//  oripa.prop_fold2xml[y] = x if y?
oripa.POINT_EPS = 1.0;

oripa.toFold = function(oripaStr) {
  var children, fold, j, k, l, len, len1, len2, len3, len4, line, lines, m, n, nodeSpec, object, oneChildSpec, oneChildText, prop, property, ref1, ref2, ref3, ref4, ref5, subproperty, top, type, vertex, x0, x1, xml, y0, y1;
  fold = {
    vertices_coords: [],
    edges_vertices: [],
    edges_assignment: [],
    file_creator: 'oripa2fold'
  };
  vertex = function(x, y) {
    var v;
    v = fold.vertices_coords.length;
    fold.vertices_coords.push([parseFloat(x), parseFloat(y)]);
    return v;
  };
  nodeSpec = function(node, type, key, value) {
    if ((type != null) && node.tagName !== type) {
      console.warn(`ORIPA file has ${node.tagName} where ${type} was expected`);
      return null;
    } else if ((key != null) && (!node.hasAttribute(key) || ((value != null) && node.getAttribute(key) !== value))) {
      console.warn(`ORIPA file has ${node.tagName} with ${key} = ${node.getAttribute(key)} where ${value} was expected`);
      return null;
    } else {
      return node;
    }
  };
  children = function(node) {
    var child, j, len, ref1, results;
    if (node) {
      ref1 = node.childNodes;
      //# element
      results = [];
      for (j = 0, len = ref1.length; j < len; j++) {
        child = ref1[j];
        if (child.nodeType === 1) {
          results.push(child);
        }
      }
      return results;
    } else {
      return [];
    }
  };
  oneChildSpec = function(node, type, key, value) {
    var sub;
    sub = children(node);
    if (sub.length !== 1) {
      console.warn(`ORIPA file has ${node.tagName} with ${node.childNodes.length} children, not 1`);
      return null;
    } else {
      return nodeSpec(sub[0], type, key, value);
    }
  };
  oneChildText = function(node) {
    var child;
    if (node.childNodes.length > 1) {
      console.warn(`ORIPA file has ${node.tagName} with ${node.childNodes.length} children, not 0 or 1`);
      return null;
    } else if (node.childNodes.length === 0) {
      return '';
    } else {
      child = node.childNodes[0];
      if (child.nodeType !== 3) {
        return console.warn(`ORIPA file has nodeType ${child.nodeType} where 3 (text) was expected`);
      } else {
        return child.data;
      }
    }
  };
  xml = new DOMParser().parseFromString(oripaStr, 'text/xml');
  ref1 = children(xml.documentElement);
  for (j = 0, len = ref1.length; j < len; j++) {
    top = ref1[j];
    if (nodeSpec(top, 'object', 'class', 'oripa.DataSet')) {
      ref2 = children(top);
      for (k = 0, len1 = ref2.length; k < len1; k++) {
        property = ref2[k];
        if (property.getAttribute('property') === 'lines') {
          lines = oneChildSpec(property, 'array', 'class', 'oripa.OriLineProxy');
          ref3 = children(lines);
          for (l = 0, len2 = ref3.length; l < len2; l++) {
            line = ref3[l];
            if (nodeSpec(line, 'void', 'index')) {
              ref4 = children(line);
              for (m = 0, len3 = ref4.length; m < len3; m++) {
                object = ref4[m];
                if (nodeSpec(object, 'object', 'class', 'oripa.OriLineProxy')) {
                  //# Java doesn't encode the default value, 0
                  x0 = x1 = y0 = y1 = type = 0;
                  ref5 = children(object);
                  for (n = 0, len4 = ref5.length; n < len4; n++) {
                    subproperty = ref5[n];
                    if (nodeSpec(subproperty, 'void', 'property')) {
                      switch (subproperty.getAttribute('property')) {
                        case 'x0':
                          x0 = oneChildText(oneChildSpec(subproperty, 'double'));
                          break;
                        case 'x1':
                          x1 = oneChildText(oneChildSpec(subproperty, 'double'));
                          break;
                        case 'y0':
                          y0 = oneChildText(oneChildSpec(subproperty, 'double'));
                          break;
                        case 'y1':
                          y1 = oneChildText(oneChildSpec(subproperty, 'double'));
                          break;
                        case 'type':
                          type = oneChildText(oneChildSpec(subproperty, 'int'));
                      }
                    }
                  }
                  if ((x0 != null) && (x1 != null) && (y0 != null) && (y1 != null)) {
                    fold.edges_vertices.push([vertex(x0, y0), vertex(x1, y1)]);
                    if (type != null) {
                      type = parseInt(type);
                    }
                    fold.edges_assignment.push(oripa.type2fold[type]);
                  } else {
                    console.warn(`ORIPA line has missing data: ${x0} ${x1} ${y0} ${y1} ${type}`);
                  }
                }
              }
            }
          }
        } else if (property.getAttribute('property') in oripa.prop_xml2fold) {
          prop = oripa.prop_xml2fold[property.getAttribute('property')];
          if (prop != null) {
            fold[prop] = oneChildText(oneChildSpec(property, 'string'));
          }
        } else {
          console.warn(`Ignoring ${property.tagName} ${top.getAttribute('property')} in ORIPA file`);
        }
      }
    }
  }
  //# src/oripa/Doc.java uses absolute distance POINT_EPS = 1.0 to detect
  //# points being the same.
  filter.collapseNearbyVertices(fold, oripa.POINT_EPS);
  filter.subdivideCrossingEdges_vertices(fold, oripa.POINT_EPS);
  //# In particular, convert.removeLoopEdges fold
  convert.edges_vertices_to_faces_vertices(fold);
  return fold;
};

oripa.fromFold = function(fold) {
  var coord, edge, ei, fp, i, j, len, line, lines, ref1, s, vertex, vs, xp, z;
  if (typeof fold === 'string') {
    fold = JSON.parse(fold);
  }
  s = `<?xml version="1.0" encoding="UTF-8"?> 
<java version="1.5.0_05" class="java.beans.XMLDecoder"> 
 <object class="oripa.DataSet"> 
  <void property="mainVersion"> 
   <int>1</int> 
  </void> 
  <void property="subVersion"> 
   <int>1</int> 
  </void> 
  <void property="paperSize"> 
   <double>400.0</double> 
  </void> 
`;
  ref1 = oripa.prop_xml2fold;
  for (xp in ref1) {
    fp = ref1[xp];
    //if fp of fold
    s += `.
  <void property="${xp}"> 
   <string>${fold[fp] || ''}</string> 
  </void> 
`.slice(2);
  }
  z = 0;
  lines = (function() {
    var j, len, ref2, results;
    ref2 = fold.edges_vertices;
    results = [];
    for (ei = j = 0, len = ref2.length; j < len; ei = ++j) {
      edge = ref2[ei];
      vs = (function() {
        var k, l, len1, len2, ref3, results1;
        results1 = [];
        for (k = 0, len1 = edge.length; k < len1; k++) {
          vertex = edge[k];
          ref3 = fold.vertices_coords[vertex].slice(2);
          for (l = 0, len2 = ref3.length; l < len2; l++) {
            coord = ref3[l];
            if (coord !== 0) {
              z += 1;
            }
          }
          results1.push(fold.vertices_coords[vertex]);
        }
        return results1;
      })();
      results.push({
        x0: vs[0][0],
        y0: vs[0][1],
        x1: vs[1][0],
        y1: vs[1][1],
        type: oripa.fold2type[fold.edges_assignment[ei]] || oripa.fold2type_default
      });
    }
    return results;
  })();
  s += `.
  <void property="lines"> 
   <array class="oripa.OriLineProxy" length="${lines.length}"> 
`.slice(2);
  for (i = j = 0, len = lines.length; j < len; i = ++j) {
    line = lines[i];
    s += `.
    <void index="${i}"> 
     <object class="oripa.OriLineProxy"> 
      <void property="type"> 
       <int>${line.type}</int> 
      </void> 
      <void property="x0"> 
       <double>${line.x0}</double> 
      </void> 
      <void property="x1"> 
       <double>${line.x1}</double> 
      </void> 
      <void property="y0"> 
       <double>${line.y0}</double> 
      </void> 
      <void property="y1"> 
       <double>${line.y1}</double> 
      </void> 
     </object> 
    </void> 
`.slice(2);
  }
  s += `.
   </array> 
  </void> 
 </object> 
</java> 
`.slice(2);
  return s;
};

convert.setConverter('.fold', '.opx', oripa.fromFold);

convert.setConverter('.opx', '.fold', oripa.toFold);
