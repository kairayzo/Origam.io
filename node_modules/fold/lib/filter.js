var RepeatedPointsDS, filter, geom,
  indexOf = [].indexOf;

geom = require('./geom');

filter = exports;

filter.edgesAssigned = function(fold, target) {
  var assignment, i, k, len, ref, results;
  ref = fold.edges_assignment;
  results = [];
  for (i = k = 0, len = ref.length; k < len; i = ++k) {
    assignment = ref[i];
    if (assignment === target) {
      results.push(i);
    }
  }
  return results;
};

filter.mountainEdges = function(fold) {
  return filter.edgesAssigned(fold, 'M');
};

filter.valleyEdges = function(fold) {
  return filter.edgesAssigned(fold, 'V');
};

filter.flatEdges = function(fold) {
  return filter.edgesAssigned(fold, 'F');
};

filter.boundaryEdges = function(fold) {
  return filter.edgesAssigned(fold, 'B');
};

filter.unassignedEdges = function(fold) {
  return filter.edgesAssigned(fold, 'U');
};

filter.cutEdges = function(fold) {
  return filter.edgesAssigned(fold, 'C');
};

filter.joinEdges = function(fold) {
  return filter.edgesAssigned(fold, 'J');
};

filter.keysStartingWith = function(fold, prefix) {
  var key, results;
  results = [];
  for (key in fold) {
    if (key.slice(0, prefix.length) === prefix) {
      results.push(key);
    }
  }
  return results;
};

filter.keysEndingWith = function(fold, suffix) {
  var key, results;
  results = [];
  for (key in fold) {
    if (key.slice(-suffix.length) === suffix) {
      results.push(key);
    }
  }
  return results;
};

filter.remapField = function(fold, field, old2new) {
  /*
  old2new: null means throw away that object
  */
  var array, i, j, k, key, l, len, len1, len2, m, new2old, old, ref, ref1;
  new2old = [];
//# later overwrites earlier
  for (i = k = 0, len = old2new.length; k < len; i = ++k) {
    j = old2new[i];
    if (j != null) {
      new2old[j] = i;
    }
  }
  ref = filter.keysStartingWith(fold, `${field}_`);
  for (l = 0, len1 = ref.length; l < len1; l++) {
    key = ref[l];
    fold[key] = (function() {
      var len2, m, results;
      results = [];
      for (m = 0, len2 = new2old.length; m < len2; m++) {
        old = new2old[m];
        results.push(fold[key][old]);
      }
      return results;
    })();
  }
  ref1 = filter.keysEndingWith(fold, `_${field}`);
  for (m = 0, len2 = ref1.length; m < len2; m++) {
    key = ref1[m];
    fold[key] = (function() {
      var len3, n, ref2, results;
      ref2 = fold[key];
      results = [];
      for (n = 0, len3 = ref2.length; n < len3; n++) {
        array = ref2[n];
        results.push((function() {
          var len4, o, results1;
          results1 = [];
          for (o = 0, len4 = array.length; o < len4; o++) {
            old = array[o];
            results1.push(old2new[old]);
          }
          return results1;
        })());
      }
      return results;
    })();
  }
  return fold;
};

filter.remapFieldSubset = function(fold, field, keep) {
  var id, old2new, value;
  id = 0;
  old2new = (function() {
    var k, len, results;
    results = [];
    for (k = 0, len = keep.length; k < len; k++) {
      value = keep[k];
      if (value) {
        results.push(id++);
      } else {
        results.push(null); //# remove
      }
    }
    return results;
  })();
  filter.remapField(fold, field, old2new);
  return old2new;
};

filter.remove = function(fold, field, index) {
  var i;
  /*
  Remove given index from given field ('vertices', 'edges', 'faces'), in place.
  */
  return filter.remapFieldSubset(fold, field, (function() {
    var k, ref, results;
    results = [];
    for (i = k = 0, ref = filter.numType(fold, field); (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
      results.push(i !== index);
    }
    return results;
  })());
};

filter.removeVertex = function(fold, index) {
  return filter.remove(fold, 'vertices', index);
};

filter.removeEdge = function(fold, index) {
  return filter.remove(fold, 'edges', index);
};

filter.removeFace = function(fold, index) {
  return filter.remove(fold, 'faces', index);
};

filter.transform = function(fold, matrix) {
  var coords, k, key, l, len, len1, ref, ref1, transform;
  ref = filter.keysEndingWith(fold, "_coords");
  /*
  Transforms all fields ending in _coords (in particular, vertices_coords)
  and all fields ending in FoldTransform (in particular,
  faces_flatFoldTransform generated by convert.flat_folded_geometry)
  according to the given transformation matrix.
  */
  for (k = 0, len = ref.length; k < len; k++) {
    key = ref[k];
    fold[key] = (function() {
      var l, len1, ref1, results;
      ref1 = fold[key];
      results = [];
      for (l = 0, len1 = ref1.length; l < len1; l++) {
        coords = ref1[l];
        results.push(geom.matrixVector(matrix, coords));
      }
      return results;
    })();
  }
  ref1 = filter.keysEndingWith(fold, "FoldTransform");
  for (l = 0, len1 = ref1.length; l < len1; l++) {
    key = ref1[l];
    if (indexOf.call(key, '_') >= 0) {
      fold[key] = (function() {
        var len2, m, ref2, results;
        ref2 = fold[key];
        results = [];
        for (m = 0, len2 = ref2.length; m < len2; m++) {
          transform = ref2[m];
          results.push(geom.matrixMatrix(matrix, transform));
        }
        return results;
      })();
    }
  }
  return fold;
};

filter.numType = function(fold, type) {
  /*
  Count the maximum number of objects of a given type, by looking at all
  fields with key of the form `type_...`, and if that fails, looking at all
  fields with key of the form `..._type`.  Returns `0` if nothing found.
  */
  var counts, key, value;
  counts = (function() {
    var k, len, ref, results;
    ref = filter.keysStartingWith(fold, `${type}_`);
    results = [];
    for (k = 0, len = ref.length; k < len; k++) {
      key = ref[k];
      value = fold[key];
      if (value.length == null) {
        continue;
      }
      results.push(value.length);
    }
    return results;
  })();
  if (!counts.length) {
    counts = (function() {
      var k, len, ref, results;
      ref = filter.keysEndingWith(fold, `_${type}`);
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        key = ref[k];
        results.push(1 + Math.max(...fold[key]));
      }
      return results;
    })();
  }
  if (counts.length) {
    return Math.max(...counts);
  } else {
    return 0; //# nothing of this type
  }
};

filter.numVertices = function(fold) {
  return filter.numType(fold, 'vertices');
};

filter.numEdges = function(fold) {
  return filter.numType(fold, 'edges');
};

filter.numFaces = function(fold) {
  return filter.numType(fold, 'faces');
};

filter.removeDuplicateEdges_vertices = function(fold) {
  var edge, id, key, old2new, seen, v, w;
  seen = {};
  id = 0;
  old2new = (function() {
    var k, len, ref, results;
    ref = fold.edges_vertices;
    results = [];
    for (k = 0, len = ref.length; k < len; k++) {
      edge = ref[k];
      [v, w] = edge;
      if (v < w) {
        key = `${v},${w}`;
      } else {
        key = `${w},${v}`;
      }
      if (!(key in seen)) {
        seen[key] = id;
        id += 1;
      }
      results.push(seen[key]);
    }
    return results;
  })();
  filter.remapField(fold, 'edges', old2new);
  return old2new;
};

filter.edges_verticesIncident = function(e1, e2) {
  var k, len, v;
  for (k = 0, len = e1.length; k < len; k++) {
    v = e1[k];
    if (indexOf.call(e2, v) >= 0) {
      return v;
    }
  }
  return null;
};

//# Use hashing to find points within an epsilon > 0 distance from each other.
//# Each integer cell will have O(1) distinct points before matching
//# (number of disjoint half-unit disks that fit in a unit square).
RepeatedPointsDS = class RepeatedPointsDS {
  constructor(vertices_coords, epsilon1) {
    var base, coord, k, len, name, ref, v;
    this.vertices_coords = vertices_coords;
    this.epsilon = epsilon1;
    //# Note: if vertices_coords has some duplicates in the initial state,
    //# then we will detect them but won't remove them here.  Rather,
    //# future duplicate inserts will return the higher-index vertex.
    this.hash = {};
    ref = this.vertices_coords;
    for (v = k = 0, len = ref.length; k < len; v = ++k) {
      coord = ref[v];
      ((base = this.hash)[name = this.key(coord)] != null ? base[name] : base[name] = []).push(v);
    }
    null;
  }

  lookup(coord) {
    var k, key, l, len, len1, len2, m, ref, ref1, ref2, ref3, v, x, xr, xt, y, yr, yt;
    [x, y] = coord;
    xr = Math.round(x / this.epsilon);
    yr = Math.round(y / this.epsilon);
    ref = [xr, xr - 1, xr + 1];
    for (k = 0, len = ref.length; k < len; k++) {
      xt = ref[k];
      ref1 = [yr, yr - 1, yr + 1];
      for (l = 0, len1 = ref1.length; l < len1; l++) {
        yt = ref1[l];
        key = `${xt},${yt}`;
        ref3 = (ref2 = this.hash[key]) != null ? ref2 : [];
        for (m = 0, len2 = ref3.length; m < len2; m++) {
          v = ref3[m];
          if (this.epsilon > geom.dist(this.vertices_coords[v], coord)) {
            return v;
          }
        }
      }
    }
    return null;
  }

  key(coord) {
    var key, x, xr, y, yr;
    [x, y] = coord;
    xr = Math.round(x / this.epsilon);
    yr = Math.round(y / this.epsilon);
    return key = `${xr},${yr}`;
  }

  insert(coord) {
    var base, name, v;
    v = this.lookup(coord);
    if (v != null) {
      return v;
    }
    ((base = this.hash)[name = this.key(coord)] != null ? base[name] : base[name] = []).push(v = this.vertices_coords.length);
    this.vertices_coords.push(coord);
    return v;
  }

};

filter.collapseNearbyVertices = function(fold, epsilon) {
  var coords, old2new, vertices;
  vertices = new RepeatedPointsDS([], epsilon);
  old2new = (function() {
    var k, len, ref, results;
    ref = fold.vertices_coords;
    results = [];
    for (k = 0, len = ref.length; k < len; k++) {
      coords = ref[k];
      results.push(vertices.insert(coords));
    }
    return results;
  })();
  return filter.remapField(fold, 'vertices', old2new);
};

//# In particular: fold.vertices_coords = vertices.vertices_coords
filter.maybeAddVertex = function(fold, coords, epsilon) {
  /*
  Add a new vertex at coordinates `coords` and return its (last) index,
  unless there is already such a vertex within distance `epsilon`,
  in which case return the closest such vertex's index.
  */
  var i;
  i = geom.closestIndex(coords, fold.vertices_coords);
  if ((i != null) && epsilon >= geom.dist(coords, fold.vertices_coords[i])) {
    return i; //# Closest point is close enough
  } else {
    return fold.vertices_coords.push(coords) - 1;
  }
};

filter.addVertexLike = function(fold, oldVertexIndex) {
  var k, key, len, ref, vNew;
  //# Add a vertex and copy data from old vertex.
  vNew = filter.numVertices(fold);
  ref = filter.keysStartingWith(fold, 'vertices_');
  for (k = 0, len = ref.length; k < len; k++) {
    key = ref[k];
    switch (key.slice(6)) {
      case 'vertices':
        break;
      default:
        //# Leaving these broken
        fold[key][vNew] = fold[key][oldVertexIndex];
    }
  }
  return vNew;
};

filter.addEdgeLike = function(fold, oldEdgeIndex, v1, v2) {
  var eNew, k, key, len, ref;
  //# Add an edge between v1 and v2, and copy data from old edge.
  //# If v1 or v2 are unspecified, defaults to the vertices of the old edge.
  //# Must have `edges_vertices` property.
  eNew = fold.edges_vertices.length;
  ref = filter.keysStartingWith(fold, 'edges_');
  for (k = 0, len = ref.length; k < len; k++) {
    key = ref[k];
    switch (key.slice(6)) {
      case 'vertices':
        fold.edges_vertices.push([v1 != null ? v1 : fold.edges_vertices[oldEdgeIndex][0], v2 != null ? v2 : fold.edges_vertices[oldEdgeIndex][1]]);
        break;
      case 'edges':
        break;
      default:
        //# Leaving these broken
        fold[key][eNew] = fold[key][oldEdgeIndex];
    }
  }
  return eNew;
};

filter.addVertexAndSubdivide = function(fold, coords, epsilon) {
  var changedEdges, e, i, iNew, k, len, ref, s, u, v;
  v = filter.maybeAddVertex(fold, coords, epsilon);
  changedEdges = [];
  if (v === fold.vertices_coords.length - 1) {
    ref = fold.edges_vertices;
    //# Similar to "Handle overlapping edges" case:
    for (i = k = 0, len = ref.length; k < len; i = ++k) {
      e = ref[i];
      if (indexOf.call(e, v) >= 0) { // shouldn't happen
        continue;
      }
      s = (function() {
        var l, len1, results;
        results = [];
        for (l = 0, len1 = e.length; l < len1; l++) {
          u = e[l];
          results.push(fold.vertices_coords[u]);
        }
        return results;
      })();
      if (geom.pointStrictlyInSegment(coords, s)) { //# implicit epsilon
        //console.log coords, 'in', s
        iNew = filter.addEdgeLike(fold, i, v, e[1]);
        changedEdges.push(i, iNew);
        e[1] = v;
      }
    }
  }
  return [v, changedEdges];
};

filter.removeLoopEdges = function(fold) {
  var edge;
  /*
  Remove edges whose endpoints are identical.  After collapsing via
  `filter.collapseNearbyVertices`, this removes epsilon-length edges.
  */
  return filter.remapFieldSubset(fold, 'edges', (function() {
    var k, len, ref, results;
    ref = fold.edges_vertices;
    results = [];
    for (k = 0, len = ref.length; k < len; k++) {
      edge = ref[k];
      results.push(edge[0] !== edge[1]);
    }
    return results;
  })());
};

filter.subdivideCrossingEdges_vertices = function(fold, epsilon, involvingEdgesFrom) {
  /*
  Using just `vertices_coords` and `edges_vertices` and assuming all in 2D,
  subdivides all crossing/touching edges to form a planar graph.
  In particular, all duplicate and loop edges are also removed.

  If called without `involvingEdgesFrom`, does all subdivision in quadratic
  time.  xxx Should be O(n log n) via plane sweep.
  In this case, returns an array of indices of all edges that were subdivided
  (both modified old edges and new edges).

  If called with `involvingEdgesFrom`, does all subdivision involving an
  edge numbered `involvingEdgesFrom` or higher.  For example, after adding an
  edge with largest number, call with `involvingEdgesFrom =
  edges_vertices.length - 1`; then this will run in linear time.
  In this case, returns two arrays of edges: the first array are all subdivided
  from the "involved" edges, while the second array is the remaining subdivided
  edges.
  */
  var addEdge, changedEdges, cross, crossI, e, e1, e2, i, i1, i2, k, l, len, len1, len2, len3, m, n, old2new, p, ref, ref1, ref2, ref3, s, s1, s2, u, v, vertices;
  changedEdges = [[], []];
  addEdge = function(v1, v2, oldEdgeIndex, which) {
    var eNew;
    //console.log 'adding', oldEdgeIndex, fold.edges_vertices.length, 'to', which
    eNew = filter.addEdgeLike(fold, oldEdgeIndex, v1, v2);
    return changedEdges[which].push(oldEdgeIndex, eNew);
  };
  //# Handle overlapping edges by subdividing edges at any vertices on them.
  //# We use a while loop instead of a for loop to process newly added edges.
  i = involvingEdgesFrom != null ? involvingEdgesFrom : 0;
  while (i < fold.edges_vertices.length) {
    e = fold.edges_vertices[i];
    s = (function() {
      var k, len, results;
      results = [];
      for (k = 0, len = e.length; k < len; k++) {
        u = e[k];
        results.push(fold.vertices_coords[u]);
      }
      return results;
    })();
    ref = fold.vertices_coords;
    for (v = k = 0, len = ref.length; k < len; v = ++k) {
      p = ref[v];
      if (indexOf.call(e, v) >= 0) {
        continue;
      }
      if (geom.pointStrictlyInSegment(p, s)) { //# implicit epsilon
        //console.log p, 'in', s
        addEdge(v, e[1], i, 0);
        e[1] = v;
      }
    }
    i++;
  }
  //# Handle crossing edges
  //# We use a while loop instead of a for loop to process newly added edges.
  vertices = new RepeatedPointsDS(fold.vertices_coords, epsilon);
  i1 = involvingEdgesFrom != null ? involvingEdgesFrom : 0;
  while (i1 < fold.edges_vertices.length) {
    e1 = fold.edges_vertices[i1];
    s1 = (function() {
      var l, len1, results;
      results = [];
      for (l = 0, len1 = e1.length; l < len1; l++) {
        v = e1[l];
        results.push(fold.vertices_coords[v]);
      }
      return results;
    })();
    ref1 = fold.edges_vertices.slice(0, i1);
    for (i2 = l = 0, len1 = ref1.length; l < len1; i2 = ++l) {
      e2 = ref1[i2];
      s2 = (function() {
        var len2, m, results;
        results = [];
        for (m = 0, len2 = e2.length; m < len2; m++) {
          v = e2[m];
          results.push(fold.vertices_coords[v]);
        }
        return results;
      })();
      if (!filter.edges_verticesIncident(e1, e2) && geom.segmentsCross(s1, s2)) {
        //# segment intersection is too sensitive a test;
        //# segmentsCross more reliable
        //cross = segmentIntersectSegment s1, s2
        cross = geom.lineIntersectLine(s1, s2);
        if (cross == null) {
          continue;
        }
        crossI = vertices.insert(cross);
        //console.log e1, s1, 'intersects', e2, s2, 'at', cross, crossI
        if (!(indexOf.call(e1, crossI) >= 0 && indexOf.call(e2, crossI) >= 0)) { //# don't add endpoint again
          //console.log e1, e2, '->'
          if (indexOf.call(e1, crossI) < 0) {
            addEdge(crossI, e1[1], i1, 0);
            e1[1] = crossI;
            s1[1] = fold.vertices_coords[crossI];
          }
          //console.log '->', e1, fold.edges_vertices[fold.edges_vertices.length-1]
          if (indexOf.call(e2, crossI) < 0) {
            addEdge(crossI, e2[1], i2, 1);
            e2[1] = crossI;
          }
        }
      }
    }
    //console.log '->', e2, fold.edges_vertices[fold.edges_vertices.length-1]
    i1++;
  }
  old2new = filter.removeDuplicateEdges_vertices(fold);
  ref2 = [0, 1];
  for (m = 0, len2 = ref2.length; m < len2; m++) {
    i = ref2[m];
    changedEdges[i] = (function() {
      var len3, n, ref3, results;
      ref3 = changedEdges[i];
      results = [];
      for (n = 0, len3 = ref3.length; n < len3; n++) {
        e = ref3[n];
        results.push(old2new[e]);
      }
      return results;
    })();
  }
  old2new = filter.removeLoopEdges(fold);
  ref3 = [0, 1];
  for (n = 0, len3 = ref3.length; n < len3; n++) {
    i = ref3[n];
    changedEdges[i] = (function() {
      var len4, o, ref4, results;
      ref4 = changedEdges[i];
      results = [];
      for (o = 0, len4 = ref4.length; o < len4; o++) {
        e = ref4[o];
        results.push(old2new[e]);
      }
      return results;
    })();
  }
  //fold
  if (involvingEdgesFrom != null) {
    return changedEdges;
  } else {
    return changedEdges[0].concat(changedEdges[1]);
  }
};

filter.addEdgeAndSubdivide = function(fold, v1, v2, epsilon) {
  var changedEdges, changedEdges1, changedEdges2, e, i, iNew, k, len, ref;
  /*
  Add an edge between vertex indices or points `v1` and `v2`, subdivide
  as necessary, and return two arrays: all the subdivided parts of this edge,
  and all the other edges that change.
  If the edge is a loop or a duplicate, both arrays will be empty.
  */
  if (v1.length != null) {
    [v1, changedEdges1] = filter.addVertexAndSubdivide(fold, v1, epsilon);
  }
  if (v2.length != null) {
    [v2, changedEdges2] = filter.addVertexAndSubdivide(fold, v2, epsilon);
  }
  if (v1 === v2) { //# Ignore loop edges
    return [[], []];
  }
  ref = fold.edges_vertices;
  for (i = k = 0, len = ref.length; k < len; i = ++k) {
    e = ref[i];
    if ((e[0] === v1 && e[1] === v2) || (e[0] === v2 && e[1] === v1)) {
      return [[i], []]; //# Ignore duplicate edges
    }
  }
  iNew = fold.edges_vertices.push([v1, v2]) - 1;
  if (iNew) {
    changedEdges = filter.subdivideCrossingEdges_vertices(fold, epsilon, iNew);
    if (indexOf.call(changedEdges[0], iNew) < 0) {
      changedEdges[0].push(iNew);
    }
  } else {
    changedEdges = [[iNew], []];
  }
  if (changedEdges1 != null) {
    changedEdges[1].push(...changedEdges1);
  }
  if (changedEdges2 != null) {
    changedEdges[1].push(...changedEdges2);
  }
  return changedEdges;
};

filter.splitCuts = function(fold, es = filter.cutEdges(fold)) {
  var b, b1, b2, boundaries, e, e1, e2, ev, i, i1, i2, ie, ie1, ie2, k, l, len, len1, len2, len3, len4, len5, len6, len7, len8, m, n, neighbor, neighbors, o, q, r, ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, t, u1, u2, v, v1, v2, ve, vertices_boundaries, z;
  if (!es.length) {
    /*
    Given a FOLD object with `edges_vertices`, `edges_assignment`, and
    counterclockwise-sorted `vertices_edges`
    (see `FOLD.convert.edges_vertices_to_vertices_edges_sorted`),
    cuts apart ("unwelds") all edges in `es` into pairs of boundary edges.
    When an endpoint of a cut edge ends up on n boundaries,
    it splits into n vertices.
    Preserves above-mentioned properties (so you can then compute faces via
    `FOLD.convert.edges_vertices_to_faces_vertices_edges`),
    and recomputes `vertices_vertices` if present,
    but ignores face properties.
    `es` is unspecified, cuts all edges with an assignment of `"C"`,
    effectively switching from FOLD 1.2's `"C"` assignments to
    FOLD 1.1's `"B"` assignments.
    */
    return fold;
  }
  //# Maintain map from every vertex to array of incident boundary edges
  vertices_boundaries = [];
  ref = filter.boundaryEdges(fold);
  for (k = 0, len = ref.length; k < len; k++) {
    e = ref[k];
    ref1 = fold.edges_vertices[e];
    for (l = 0, len1 = ref1.length; l < len1; l++) {
      v = ref1[l];
      (vertices_boundaries[v] != null ? vertices_boundaries[v] : vertices_boundaries[v] = []).push(e);
    }
  }
  for (m = 0, len2 = es.length; m < len2; m++) {
    e1 = es[m];
    //# Split e1 into two edges {e1, e2}
    e2 = filter.addEdgeLike(fold, e1);
    ref2 = fold.edges_vertices[e1];
    for (i = n = 0, len3 = ref2.length; n < len3; i = ++n) {
      v = ref2[i];
      ve = fold.vertices_edges[v];
      //# Insert e2 before e1 in first vertex and after e1 in second vertex
      //# to represent valid counterclockwise ordering
      ve.splice(ve.indexOf(e1) + i, 0, e2);
    }
    ref3 = fold.edges_vertices[e1];
    //# Check for endpoints of {e1, e2} to split, when they're on the boundary
    for (i = o = 0, len4 = ref3.length; o < len4; i = ++o) {
      v1 = ref3[i];
      u1 = fold.edges_vertices[e1][1 - i];
      u2 = fold.edges_vertices[e2][1 - i];
      boundaries = (ref4 = vertices_boundaries[v1]) != null ? ref4.length : void 0;
      if (boundaries >= 2) { //# vertex already on boundary
        if (boundaries > 2) {
          throw new Error(`${vertices_boundaries[v1].length} boundary edges at vertex ${v1}`);
        }
        [b1, b2] = vertices_boundaries[v1];
        neighbors = fold.vertices_edges[v1];
        i1 = neighbors.indexOf(b1);
        i2 = neighbors.indexOf(b2);
        if (i2 === (i1 + 1) % neighbors.length) {
          if (i2 !== 0) {
            neighbors = neighbors.slice(i2).concat(neighbors.slice(0, +i1 + 1 || 9e9));
          }
        } else if (i1 === (i2 + 1) % neighbors.length) {
          if (i1 !== 0) {
            neighbors = neighbors.slice(i1).concat(neighbors.slice(0, +i2 + 1 || 9e9));
          }
        } else {
          throw new Error(`Nonadjacent boundary edges at vertex ${v1}`);
        }
        //# Find first vertex among e1, e2 among neighbors, so other is next
        ie1 = neighbors.indexOf(e1);
        ie2 = neighbors.indexOf(e2);
        ie = Math.min(ie1, ie2);
        fold.vertices_edges[v1] = neighbors.slice(0, +ie + 1 || 9e9);
        v2 = filter.addVertexLike(fold, v1);
        fold.vertices_edges[v2] = neighbors.slice(1 + ie);
        ref5 = fold.vertices_edges[v2];
        //console.log "Split #{neighbors} into #{fold.vertices_edges[v1]} for #{v1} and #{fold.vertices_edges[v2]} for #{v2}"
        //# Update relevant incident edges to use v2 instead of v1
        for (q = 0, len5 = ref5.length; q < len5; q++) {
          neighbor = ref5[q];
          ev = fold.edges_vertices[neighbor];
          ev[ev.indexOf(v1)] = v2;
        }
        //# Partition boundary edges incident to v1
        vertices_boundaries[v1] = [];
        vertices_boundaries[v2] = [];
        ref6 = [b1, b2];
        for (r = 0, len6 = ref6.length; r < len6; r++) {
          b = ref6[r];
          if (indexOf.call(fold.vertices_edges[v1], b) >= 0) {
            vertices_boundaries[v1].push(b); //if b in fold.vertices_edges[v2]
          } else {
            vertices_boundaries[v2].push(b);
          }
        }
      }
    }
    //# e1 and e2 are new boundary edges
    if ((ref7 = fold.edges_assignment) != null) {
      ref7[e1] = 'B';
    }
    if ((ref8 = fold.edges_assignment) != null) {
      ref8[e2] = 'B';
    }
    ref9 = fold.edges_vertices[e1];
    for (i = t = 0, len7 = ref9.length; t < len7; i = ++t) {
      v = ref9[i];
      (vertices_boundaries[v] != null ? vertices_boundaries[v] : vertices_boundaries[v] = []).push(e1);
    }
    ref10 = fold.edges_vertices[e2];
    for (i = z = 0, len8 = ref10.length; z < len8; i = ++z) {
      v = ref10[i];
      (vertices_boundaries[v] != null ? vertices_boundaries[v] : vertices_boundaries[v] = []).push(e2);
    }
  }
  if (fold.vertices_vertices != null) {
    fold.vertices_vertices = filter.edges_vertices_to_vertices_vertices(fold); // would be out-of-date
  }
  return fold;
};

filter.edges_vertices_to_vertices_vertices = function(fold) {
  /*
  Works for abstract structures, so NOT SORTED.
  Use sort_vertices_vertices to sort in counterclockwise order.
  */
  var k, len, numVertices, ref, v, vertices_vertices, w;
  numVertices = filter.numVertices(fold);
  vertices_vertices = (function() {
    var k, ref, results;
    results = [];
    for (v = k = 0, ref = numVertices; (0 <= ref ? k < ref : k > ref); v = 0 <= ref ? ++k : --k) {
      results.push([]);
    }
    return results;
  })();
  ref = fold.edges_vertices;
  for (k = 0, len = ref.length; k < len; k++) {
    [v, w] = ref[k];
    while (v >= vertices_vertices.length) {
      vertices_vertices.push([]);
    }
    while (w >= vertices_vertices.length) {
      vertices_vertices.push([]);
    }
    vertices_vertices[v].push(w);
    vertices_vertices[w].push(v);
  }
  return vertices_vertices;
};

filter.edges_vertices_to_vertices_edges = function(fold) {
  /*
  Invert edges_vertices into vertices_edges.
  Works for abstract structures, so NOT SORTED in any sense.
  */
  var edge, k, l, len, len1, numVertices, ref, v, vertex, vertices, vertices_edges;
  numVertices = filter.numVertices(fold);
  vertices_edges = (function() {
    var k, ref, results;
    results = [];
    for (v = k = 0, ref = numVertices; (0 <= ref ? k < ref : k > ref); v = 0 <= ref ? ++k : --k) {
      results.push([]);
    }
    return results;
  })();
  ref = fold.edges_vertices;
  for (edge = k = 0, len = ref.length; k < len; edge = ++k) {
    vertices = ref[edge];
    for (l = 0, len1 = vertices.length; l < len1; l++) {
      vertex = vertices[l];
      vertices_edges[vertex].push(edge);
    }
  }
  return vertices_edges;
};
