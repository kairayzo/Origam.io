  /* BASIC GEOMETRY */
var geom,
  modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

geom = exports;

/*
    Utilities
*/
geom.EPS = 0.000001;

geom.sum = function(a, b) {
  return a + b;
};

geom.min = function(a, b) {
  if (a < b) {
    return a;
  } else {
    return b;
  }
};

geom.max = function(a, b) {
  if (a > b) {
    return a;
  } else {
    return b;
  }
};

geom.all = function(a, b) {
  return a && b;
};

geom.next = function(start, n, i = 1) {
  /*
  Returns the ith cyclic ordered number after start in the range [0..n].
  */
  return modulo(start + i, n);
};

geom.rangesDisjoint = function([a1, a2], [b1, b2]) {
  var ref, ref1;
  //# Returns whether the scalar interval [a1, a2] is disjoint from the scalar
  //# interval [b1,b2].
  return ((b1 < (ref = Math.min(a1, a2)) && ref > b2)) || ((b1 > (ref1 = Math.max(a1, a2)) && ref1 < b2));
};

geom.topologicalSort = function(vs) {
  var l, len, list, v;
  (function() {
    var l, len, results;
    results = [];
    for (l = 0, len = vs.length; l < len; l++) {
      v = vs[l];
      results.push([v.visited, v.parent] = [false, null]);
    }
    return results;
  })();
  list = [];
  for (l = 0, len = vs.length; l < len; l++) {
    v = vs[l];
    if (!v.visited) {
      list = geom.visit(v, list);
    }
  }
  return list;
};

geom.visit = function(v, list) {
  var l, len, ref, u;
  v.visited = true;
  ref = v.children;
  for (l = 0, len = ref.length; l < len; l++) {
    u = ref[l];
    if (!(!u.visited)) {
      continue;
    }
    u.parent = v;
    list = geom.visit(u, list);
  }
  return list.concat([v]);
};

//#
//# Vector operations
//#
geom.magsq = function(a) {
  //# Returns the squared magnitude of vector a having arbitrary dimension.
  return geom.dot(a, a);
};

geom.mag = function(a) {
  //# Returns the magnitude of vector a having arbitrary dimension.
  return Math.sqrt(geom.magsq(a));
};

geom.unit = function(a, eps = geom.EPS) {
  var length;
  //# Returns the unit vector in the direction of vector a having arbitrary
  //# dimension. Returns null if magnitude of a is zero.
  length = geom.magsq(a);
  if (length < eps) {
    return null;
  }
  return geom.mul(a, 1 / geom.mag(a));
};

geom.ang2D = function(a, eps = geom.EPS) {
  if (geom.magsq(a) < eps) {
    //# Returns the angle of a 2D vector relative to the standard
    //# east-is-0-degrees rule.
    return null;
  }
  return Math.atan2(a[1], a[0]);
};

geom.mul = function(a, s) {
  var i, l, len, results;
  results = [];
  for (l = 0, len = a.length; l < len; l++) {
    i = a[l];
    //# Returns the vector a multiplied by scaler factor s.
    results.push(i * s);
  }
  return results;
};

geom.linearInterpolate = function(t, a, b) {
  //# Returns linear interpolation of vector a to vector b for 0 < t < 1
  return geom.plus(geom.mul(a, 1 - t), geom.mul(b, t));
};

geom.plus = function(a, b) {
  var ai, i, l, len, results;
  results = [];
  for (i = l = 0, len = a.length; l < len; i = ++l) {
    ai = a[i];
    //# Returns the vector sum between of vectors a and b having the same
    //# dimension.
    results.push(ai + b[i]);
  }
  return results;
};

geom.sub = function(a, b) {
  //# Returns the vector difference of vectors a and b having the same dimension.
  return geom.plus(a, geom.mul(b, -1));
};

geom.dot = function(a, b) {
  var ai, i;
  return ((function() {
    var l, len, results;
    results = [];
    for (i = l = 0, len = a.length; l < len; i = ++l) {
      ai = a[i];
      //# Returns the dot product between two vectors a and b having the same
      //# dimension.
      results.push(ai * b[i]);
    }
    return results;
  })()).reduce(geom.sum);
};

geom.distsq = function(a, b) {
  //# Returns the squared Euclidean distance between two vectors a and b having 
  //# the same dimension.
  return geom.magsq(geom.sub(a, b));
};

geom.dist = function(a, b) {
  //# Returns the Euclidean distance between general vectors a and b having the
  //# same dimension.
  return Math.sqrt(geom.distsq(a, b));
};

geom.closestIndex = function(a, bs) {
  var b, dist, i, l, len, minDist, minI;
  //# Finds the closest point to `a` among points in `bs`, and returns the
  //# index of that point in `bs`.  Returns `undefined` if `bs` is empty.
  minDist = 2e308;
  for (i = l = 0, len = bs.length; l < len; i = ++l) {
    b = bs[i];
    if (minDist > (dist = geom.dist(a, b))) {
      minDist = dist;
      minI = i;
    }
  }
  return minI;
};

geom.dir = function(a, b) {
  //# Returns a unit vector in the direction from vector a to vector b, in the
  //# same dimension as a and b.
  return geom.unit(geom.sub(b, a));
};

geom.ang = function(a, b) {
  var ua, ub, v;
  //# Returns the angle spanned by vectors a and b having the same dimension.
  [ua, ub] = (function() {
    var l, len, ref, results;
    ref = [a, b];
    results = [];
    for (l = 0, len = ref.length; l < len; l++) {
      v = ref[l];
      results.push(geom.unit(v));
    }
    return results;
  })();
  if (!((ua != null) && (ub != null))) {
    return null;
  }
  return Math.acos(geom.dot(ua, ub));
};

geom.cross = function(a, b) {
  var i, j, ref, ref1;
  //# Returns the cross product of two 2D or 3D vectors a, b.
  if ((a.length === (ref = b.length) && ref === 2)) {
    return a[0] * b[1] - a[1] * b[0];
  }
  if ((a.length === (ref1 = b.length) && ref1 === 3)) {
    return (function() {
      var l, len, ref2, results;
      ref2 = [[1, 2], [2, 0], [0, 1]];
      results = [];
      for (l = 0, len = ref2.length; l < len; l++) {
        [i, j] = ref2[l];
        results.push(a[i] * b[j] - a[j] * b[i]);
      }
      return results;
    })();
  }
  return null;
};

geom.parallel = function(a, b, eps = geom.EPS) {
  var ua, ub, v;
  //# Return if vectors are parallel, up to accuracy eps
  [ua, ub] = (function() {
    var l, len, ref, results;
    ref = [a, b];
    results = [];
    for (l = 0, len = ref.length; l < len; l++) {
      v = ref[l];
      results.push(geom.unit(v));
    }
    return results;
  })();
  if (!((ua != null) && (ub != null))) {
    return null;
  }
  return 1 - Math.abs(geom.dot(ua, ub)) < eps;
};

geom.rotate = function(a, u, t) {
  var ct, i, l, len, p, q, ref, results, st;
  //# Returns the rotation of 3D vector a about 3D unit vector u by angle t.
  u = geom.unit(u);
  if (u == null) {
    return null;
  }
  [ct, st] = [Math.cos(t), Math.sin(t)];
  ref = [[0, 1, 2], [1, 2, 0], [2, 0, 1]];
  results = [];
  for (l = 0, len = ref.length; l < len; l++) {
    p = ref[l];
    results.push(((function() {
      var len1, o, ref1, results1;
      ref1 = [ct, -st * u[p[2]], st * u[p[1]]];
      results1 = [];
      for (i = o = 0, len1 = ref1.length; o < len1; i = ++o) {
        q = ref1[i];
        results1.push(a[p[i]] * (u[p[0]] * u[p[i]] * (1 - ct) + q));
      }
      return results1;
    })()).reduce(geom.sum));
  }
  return results;
};

geom.reflectPoint = function(p, q) {
  //# Reflect point p through the point q into the "symmetric point"
  return geom.sub(geom.mul(q, 2), p);
};

geom.reflectLine = function(p, a, b) {
  var dot, lenSq, projection, vec;
  //# Reflect point p through line through points a and b
  // [based on https://math.stackexchange.com/a/11532]
  // projection = a + (b - a) * [(b - a) dot (p - a)] / ||b - a||^2
  vec = geom.sub(b, a);
  lenSq = geom.magsq(vec);
  dot = geom.dot(vec, geom.sub(p, a));
  projection = geom.plus(a, geom.mul(vec, dot / lenSq));
  // reflection = 2*projection - p (symmetric point of p opposite projection)
  return geom.sub(geom.mul(projection, 2), p);
};

/*
Matrix transformations

2D transformation matrices are of the form (where last column is optional):
  [[a, b, c],
   [d, e, f]]

3D transformation matrices are of the form (where last column is optional):
  [[a, b, c, d],
   [e, f, g, h],
   [i, j, k, l]]

Transformation matrices are designed to be multiplied on the left of points,
i.e., T*x gives vector x transformed by matrix T, where x has an implicit 1
at the end (homogeneous coordinates) when T has the optional last column.
See `geom.matrixVector`.
*/
geom.matrixVector = function(matrix, vector, implicitLast = 1) {
  var j, l, len, results, row, val, x;
//# Returns matrix-vector product, matrix * vector.
//# Requires the number of matrix columns to be <= vector length.
//# If the matrix has more columns than the vector length, then the vector
//# is assumed to be padded with zeros at the end, EXCEPT when the matrix
//# has more columns than rows (as in transformation matrices above),
//# in which case the final vector padding is implicitLast,
//# which defaults to 1 (point); set to 0 for treating like a vector.
  results = [];
  for (l = 0, len = matrix.length; l < len; l++) {
    row = matrix[l];
    val = ((function() {
      var len1, o, results1;
      results1 = [];
      for (j = o = 0, len1 = vector.length; o < len1; j = ++o) {
        x = vector[j];
        results1.push(row[j] * x);
      }
      return results1;
    })()).reduce(geom.sum);
    if (row.length > vector.length && row.length > matrix.length) {
      val += row[row.length - 1] * implicitLast;
    }
    results.push(val);
  }
  return results;
};

geom.matrixMatrix = function(matrix1, matrix2) {
  var j, k, l, len, product, ref, ref1, results, row1, row2, val;
//# Returns matrix-matrix product, matrix1 * matrix2.
//# Requires number of matrix1 columns equal to or 1 more than matrix2 rows.
//# In the latter case, treats matrix2 as having an extra row [0,0,...,0,0,1],
//# which may involve adding an implicit column to matrix2 as well.
  results = [];
  for (l = 0, len = matrix1.length; l < len; l++) {
    row1 = matrix1[l];
    if ((matrix2.length !== (ref = row1.length) && ref !== matrix2.length + 1)) {
      throw new Error(`Invalid matrix dimension ${row1.length} vs. matrix dimension ${matrix2.length}`);
    }
    product = (function() {
      var o, ref1, ref2, results1;
      results1 = [];
      for (j = o = 0, ref1 = matrix2[0].length; (0 <= ref1 ? o < ref1 : o > ref1); j = 0 <= ref1 ? ++o : --o) {
        val = ((function() {
          var len1, r, results2;
          results2 = [];
          for (k = r = 0, len1 = matrix2.length; r < len1; k = ++r) {
            row2 = matrix2[k];
            results2.push(row1[k] * row2[j]);
          }
          return results2;
        })()).reduce(geom.sum);
        if ((j === (ref2 = row1.length - 1) && ref2 === matrix2.length)) {
          val += row1[j];
        }
        results1.push(val);
      }
      return results1;
    })();
    if ((row1.length - 1 === (ref1 = matrix2.length) && ref1 === matrix2[0].length)) {
      product.push(row1[row1.length - 1]);
    }
    results.push(product);
  }
  return results;
};

geom.matrixInverseRT = function(matrix) {
  var i, invRow, j, l, lastCol, len, results, row;
  //# Returns inverse of a matrix consisting of rotations and/or translations,
  //# where the inverse can be found by a transpose and dot products
  //# [http://www.graphics.stanford.edu/courses/cs248-98-fall/Final/q4.html].
  if (matrix[0].length === matrix.length + 1) {
    lastCol = (function() {
      var l, len, results;
      results = [];
      for (l = 0, len = matrix.length; l < len; l++) {
        row = matrix[l];
        results.push(row[row.length - 1]);
      }
      return results;
    })();
  } else if (matrix[0].length !== matrix.length) {
    throw new Error(`Invalid matrix dimensions ${matrix.length}x${matrix[0].length}`);
  }
  results = [];
  for (i = l = 0, len = matrix.length; l < len; i = ++l) {
    row = matrix[i];
    invRow = (function() {
      var o, ref, results1;
// transpose
      results1 = [];
      for (j = o = 0, ref = matrix.length; (0 <= ref ? o < ref : o > ref); j = 0 <= ref ? ++o : --o) {
        results1.push(matrix[j][i]);
      }
      return results1;
    })();
    if (lastCol != null) {
      invRow.push(-geom.dot(row.slice(0, matrix.length), lastCol));
    }
    results.push(invRow);
  }
  return results;
};

geom.matrixInverse = function(matrix) {
  var bestRow, i, inverse, j, l, o, r, ref, ref1, ref2, ref3, ref4, ref5, row, w;
  //# Returns inverse of a matrix computed via Gauss-Jordan elimination method.
  if ((matrix.length !== (ref = matrix[0].length) && ref !== matrix.length + 1)) {
    throw new Error(`Invalid matrix dimensions ${matrix.length}x${matrix[0].length}`);
  }
  matrix = (function() {
    var l, len, results;
// copy before elimination
    results = [];
    for (l = 0, len = matrix.length; l < len; l++) {
      row = matrix[l];
      results.push(row.slice(0));
    }
    return results;
  })();
  inverse = (function() {
    var l, len, results;
    results = [];
    for (i = l = 0, len = matrix.length; l < len; i = ++l) {
      row = matrix[i];
      results.push((function() {
        var o, ref1, results1;
        results1 = [];
        for (j = o = 0, ref1 = row.length; (0 <= ref1 ? o < ref1 : o > ref1); j = 0 <= ref1 ? ++o : --o) {
          results1.push(0 + (i === j));
        }
        return results1;
      })());
    }
    return results;
  })();
  for (j = l = 0, ref1 = matrix.length; (0 <= ref1 ? l < ref1 : l > ref1); j = 0 <= ref1 ? ++l : --l) {
    // Pivot to maximize absolute value in jth column
    bestRow = j;
    for (i = o = ref2 = j + 1, ref3 = matrix.length; (ref2 <= ref3 ? o < ref3 : o > ref3); i = ref2 <= ref3 ? ++o : --o) {
      if (Math.abs(matrix[i][j]) > Math.abs(matrix[bestRow][j])) {
        bestRow = i;
      }
    }
    if (bestRow !== j) {
      [matrix[bestRow], matrix[j]] = [matrix[j], matrix[bestRow]];
      [inverse[bestRow], inverse[j]] = [inverse[j], inverse[bestRow]];
    }
    // Scale row to unity in jth column
    inverse[j] = geom.mul(inverse[j], 1 / matrix[j][j]);
    matrix[j] = geom.mul(matrix[j], 1 / matrix[j][j]);
// Eliminate other rows in jth column
    for (i = r = 0, ref4 = matrix.length; (0 <= ref4 ? r < ref4 : r > ref4); i = 0 <= ref4 ? ++r : --r) {
      if (!(i !== j)) {
        continue;
      }
      inverse[i] = geom.plus(inverse[i], geom.mul(inverse[j], -matrix[i][j]));
      matrix[i] = geom.plus(matrix[i], geom.mul(matrix[j], -matrix[i][j]));
    }
  }
  if (matrix[0].length === matrix.length + 1) {
    for (i = w = 0, ref5 = matrix.length; (0 <= ref5 ? w < ref5 : w > ref5); i = 0 <= ref5 ? ++w : --w) {
      if (!(i !== j)) {
        continue;
      }
      inverse[i][inverse[i].length - 1] -= matrix[i][matrix[i].length - 1];
      matrix[i][matrix[i].length - 1] -= matrix[i][matrix[i].length - 1];
    }
  }
  return inverse;
};

geom.matrixTranslate = function(v) {
  var i, j, l, len, results, row, x;
//# Transformation matrix for translating by given vector v.
//# Works in any dimension, assuming v.length is that dimension.
  results = [];
  for (i = l = 0, len = v.length; l < len; i = ++l) {
    x = v[i];
    row = (function() {
      var o, ref, results1;
      results1 = [];
      for (j = o = 0, ref = v.length; (0 <= ref ? o < ref : o > ref); j = 0 <= ref ? ++o : --o) {
        results1.push(0 + (i === j));
      }
      return results1;
    })();
    row.push(x);
    results.push(row);
  }
  return results;
};

geom.matrixRotate2D = function(t, center) {
  var ct, st, x, y;
  //# 2D rotation matrix around center, which defaults to origin,
  //# counterclockwise by t radians.
  [ct, st] = [Math.cos(t), Math.sin(t)];
  if (center != null) {
    [x, y] = center;
    return [[ct, -st, -x * ct + y * st + x], [st, ct, -x * st - y * ct + y]];
  } else {
    return [[ct, -st], [st, ct]];
  }
};

geom.matrixReflectAxis = function(a, d, center) {
  var i, j, l, ref, results, row;
//# Matrix transformation negating dimension a out of d dimensions,
//# or if center is specified, reflecting around that value of dimension a.
  results = [];
  for (i = l = 0, ref = d; (0 <= ref ? l < ref : l > ref); i = 0 <= ref ? ++l : --l) {
    row = (function() {
      var o, ref1, results1;
      results1 = [];
      for (j = o = 0, ref1 = d; (0 <= ref1 ? o < ref1 : o > ref1); j = 0 <= ref1 ? ++o : --o) {
        if (i === j) {
          if (a === i) {
            results1.push(-1);
          } else {
            results1.push(1);
          }
        } else {
          results1.push(0);
        }
      }
      return results1;
    })();
    if (center != null) {
      if (a === i) {
        row.push(2 * center);
      } else {
        row.push(0);
      }
    }
    results.push(row);
  }
  return results;
};

geom.matrixReflectLine = function(a, b) {
  var dot2, lenSq, vec;
  //# Matrix transformation implementing 2D geom.reflectLine(*, a, b)
  vec = geom.sub(b, a);
  lenSq = geom.magsq(vec);
  // dot = vec dot (p - a) = vec dot p - vec dot a
  dot2 = geom.dot(vec, a);
  //proj = (a[i] + vec[i] * dot / lenSq for i in [0...2])
  //[[vec[0] * vec[0] / lenSq,
  //  vec[0] * vec[1] / lenSq,
  //  a[0] - vec[0] * dot2 / lenSq]
  // [vec[1] * vec[0] / lenSq,
  //  vec[1] * vec[1] / lenSq,
  //  a[1] - vec[1] * dot2 / lenSq]]
  return [[2 * (vec[0] * vec[0] / lenSq) - 1, 2 * (vec[0] * vec[1] / lenSq), 2 * (a[0] - vec[0] * dot2 / lenSq)], [2 * (vec[1] * vec[0] / lenSq), 2 * (vec[1] * vec[1] / lenSq) - 1, 2 * (a[1] - vec[1] * dot2 / lenSq)]];
};

//#
//# Polygon Operations
//#
geom.interiorAngle = function(a, b, c) {
  var ang;
  //# Computes the angle of three points that are, say, part of a triangle.
  //# Specify in counterclockwise order.
  //#          a
  //#         /
  //#        /
  //#      b/_)__ c
  ang = geom.ang2D(geom.sub(a, b)) - geom.ang2D(geom.sub(c, b));
  return ang + (ang < 0 ? 2 * Math.PI : 0);
};

geom.turnAngle = function(a, b, c) {
  //# Returns the turn angle, the supplement of the interior angle
  return Math.PI - geom.interiorAngle(a, b, c);
};

geom.triangleNormal = function(a, b, c) {
  //# Returns the right handed normal unit vector to triangle a, b, c in 3D. If
  //# the triangle is degenerate, returns null.
  return geom.unit(geom.cross(geom.sub(b, a), geom.sub(c, b)));
};

geom.polygonNormal = function(points, eps = geom.EPS) {
  var i, p;
  //# Returns the right handed normal unit vector to the polygon defined by
  //# points in 3D. Assumes the points are planar.
  return geom.unit(((function() {
    var l, len, results;
    results = [];
    for (i = l = 0, len = points.length; l < len; i = ++l) {
      p = points[i];
      results.push(geom.cross(p, points[geom.next(i, points.length)]));
    }
    return results;
  })()).reduce(geom.plus), eps);
};

geom.twiceSignedArea = function(points) {
  var i, v0, v1;
  return ((function() {
    var l, len, results;
//# Returns twice signed area of polygon defined by input points.
//# Calculates and sums twice signed area of triangles in a fan from the first
//# vertex.
    results = [];
    for (i = l = 0, len = points.length; l < len; i = ++l) {
      v0 = points[i];
      v1 = points[geom.next(i, points.length)];
      results.push(v0[0] * v1[1] - v1[0] * v0[1]);
    }
    return results;
  })()).reduce(geom.sum);
};

geom.polygonOrientation = function(points) {
  //# Returns the orientation of the 2D polygon defined by the input points.
  //# +1 for counterclockwise, -1 for clockwise
  //# via computing sum of signed areas of triangles formed with origin
  return Math.sign(geom.twiceSignedArea(points));
};

geom.sortByAngle = function(points, origin = [0, 0], mapping = function(x) {
    return x;
  }) {
  //# Sort a set of 2D points in place counter clockwise about origin
  //# under the provided mapping.
  origin = mapping(origin);
  return points.sort(function(p, q) {
    var pa, qa;
    pa = geom.ang2D(geom.sub(mapping(p), origin));
    qa = geom.ang2D(geom.sub(mapping(q), origin));
    return pa - qa;
  });
};

geom.segmentsCross = function([p0, q0], [p1, q1]) {
  //# May not work if the segments are collinear.
  //# First do rough overlap check in x and y.  This helps with
  //# near-collinear segments.  (Inspired by oripa/geom/GeomUtil.java)
  if (geom.rangesDisjoint([p0[0], q0[0]], [p1[0], q1[0]]) || geom.rangesDisjoint([p0[1], q0[1]], [p1[1], q1[1]])) {
    return false;
  }
  //# Now do orientation test.
  return geom.polygonOrientation([p0, q0, p1]) !== geom.polygonOrientation([p0, q0, q1]) && geom.polygonOrientation([p1, q1, p0]) !== geom.polygonOrientation([p1, q1, q0]);
};

geom.parametricLineIntersect = function([p1, p2], [q1, q2]) {
  var denom;
  //# Returns the parameters s,t for the equations s*p1+(1-s)*p2 and
  //# t*q1+(1-t)*q2.  Used Maple's result of:
  //#    solve({s*p2x+(1-s)*p1x=t*q2x+(1-t)*q1x,
  //#           s*p2y+(1-s)*p1y=t*q2y+(1-t)*q1y}, {s,t});
  //# Returns null, null if the intersection couldn't be found
  //# because the lines are parallel.
  //# Input points must be 2D.
  denom = (q2[1] - q1[1]) * (p2[0] - p1[0]) + (q1[0] - q2[0]) * (p2[1] - p1[1]);
  if (denom === 0) {
    return [null, null];
  } else {
    return [(q2[0] * (p1[1] - q1[1]) + q2[1] * (q1[0] - p1[0]) + q1[1] * p1[0] - p1[1] * q1[0]) / denom, (q1[0] * (p2[1] - p1[1]) + q1[1] * (p1[0] - p2[0]) + p1[1] * p2[0] - p2[1] * p1[0]) / denom];
  }
};

geom.segmentIntersectSegment = function(s1, s2) {
  var s, t;
  [s, t] = geom.parametricLineIntersect(s1, s2);
  if ((s != null) && ((0 <= s && s <= 1)) && ((0 <= t && t <= 1))) {
    return geom.linearInterpolate(s, s1[0], s1[1]);
  } else {
    return null;
  }
};

geom.lineIntersectLine = function(l1, l2) {
  var s, t;
  [s, t] = geom.parametricLineIntersect(l1, l2);
  if (s != null) {
    return geom.linearInterpolate(s, l1[0], l1[1]);
  } else {
    return null;
  }
};

geom.pointStrictlyInSegment = function(p, s, eps = geom.EPS) {
  var v0, v1;
  v0 = geom.sub(p, s[0]);
  v1 = geom.sub(p, s[1]);
  return geom.parallel(v0, v1, eps) && geom.dot(v0, v1) < 0;
};

geom.centroid = function(points) {
  //# Returns the centroid of a set of points having the same dimension.
  return geom.mul(points.reduce(geom.plus), 1.0 / points.length);
};

geom.basis = function(ps, eps = geom.EPS) {
  var d, ds, n, ns, p, x, y, z;
  if (((function() {
    var l, len, results;
    results = [];
    for (l = 0, len = ps.length; l < len; l++) {
      p = ps[l];
      results.push(p.length !== 3);
    }
    return results;
  })()).reduce(geom.all)) {
    //# Returns a basis of a 3D point set.
    //#  - [] if the points are all the same point (0 dimensional)
    //#  - [x] if the points lie on a line with basis direction x
    //#  - [x,y] if the points lie in a plane with basis directions x and y
    //#  - [x,y,z] if the points span three dimensions
    return null;
  }
  ds = (function() {
    var l, len, results;
    results = [];
    for (l = 0, len = ps.length; l < len; l++) {
      p = ps[l];
      if (geom.distsq(p, ps[0]) > eps) {
        results.push(geom.dir(p, ps[0]));
      }
    }
    return results;
  })();
  if (ds.length === 0) {
    return [];
  }
  x = ds[0];
  if (((function() {
    var l, len, results;
    results = [];
    for (l = 0, len = ds.length; l < len; l++) {
      d = ds[l];
      results.push(geom.parallel(d, x, eps));
    }
    return results;
  })()).reduce(geom.all)) {
    return [x];
  }
  ns = (function() {
    var l, len, results;
    results = [];
    for (l = 0, len = ds.length; l < len; l++) {
      d = ds[l];
      results.push(geom.unit(geom.cross(d, x)));
    }
    return results;
  })();
  ns = (function() {
    var l, len, results;
    results = [];
    for (l = 0, len = ns.length; l < len; l++) {
      n = ns[l];
      if (n != null) {
        results.push(n);
      }
    }
    return results;
  })();
  z = ns[0];
  y = geom.cross(z, x);
  if (((function() {
    var l, len, results;
    results = [];
    for (l = 0, len = ns.length; l < len; l++) {
      n = ns[l];
      results.push(geom.parallel(n, z, eps));
    }
    return results;
  })()).reduce(geom.all)) {
    return [x, y];
  }
  return [x, y, z];
};

geom.above = function(ps, qs, n, eps = geom.EPS) {
  var pn, qn, v, vs;
  [pn, qn] = (function() {
    var l, len, ref, results;
    ref = [ps, qs];
    results = [];
    for (l = 0, len = ref.length; l < len; l++) {
      vs = ref[l];
      results.push((function() {
        var len1, o, results1;
        results1 = [];
        for (o = 0, len1 = vs.length; o < len1; o++) {
          v = vs[o];
          results1.push(geom.dot(v, n));
        }
        return results1;
      })());
    }
    return results;
  })();
  if (qn.reduce(geom.max) - pn.reduce(geom.min) < eps) {
    return 1;
  }
  if (pn.reduce(geom.max) - qn.reduce(geom.min) < eps) {
    return -1;
  }
  return 0;
};

geom.separatingDirection2D = function(t1, t2, n, eps = geom.EPS) {
  var i, j, l, len, len1, len2, m, o, p, q, r, ref, sign, t;
  ref = [t1, t2];
  //# If points are contained in a common plane with normal n and a separating 
  //# direction exists, a direction perpendicular to some pair of points from 
  //# the same set is also a separating direction.
  for (l = 0, len = ref.length; l < len; l++) {
    t = ref[l];
    for (i = o = 0, len1 = t.length; o < len1; i = ++o) {
      p = t[i];
      for (j = r = 0, len2 = t.length; r < len2; j = ++r) {
        q = t[j];
        if (!(i < j)) {
          continue;
        }
        m = geom.unit(geom.cross(geom.sub(p, q), n));
        if (m != null) {
          sign = geom.above(t1, t2, m, eps);
          if (sign !== 0) {
            return geom.mul(m, sign);
          }
        }
      }
    }
  }
  return null;
};

geom.separatingDirection3D = function(t1, t2, eps = geom.EPS) {
  var i, j, l, len, len1, len2, len3, m, o, p, q1, q2, r, ref, sign, w, x1, x2;
  ref = [[t1, t2], [t2, t1]];
  //# If points are not contained in a common plane and a separating direction
  //# exists, a plane spanning two points from one set and one point from the
  //# other set is a separating plane, with its normal a separating direction. 
  for (l = 0, len = ref.length; l < len; l++) {
    [x1, x2] = ref[l];
    for (o = 0, len1 = x1.length; o < len1; o++) {
      p = x1[o];
      for (i = r = 0, len2 = x2.length; r < len2; i = ++r) {
        q1 = x2[i];
        for (j = w = 0, len3 = x2.length; w < len3; j = ++w) {
          q2 = x2[j];
          if (!(i < j)) {
            continue;
          }
          m = geom.unit(geom.cross(geom.sub(p, q1), geom.sub(p, q2)));
          if (m != null) {
            sign = geom.above(t1, t2, m, eps);
            if (sign !== 0) {
              return geom.mul(m, sign);
            }
          }
        }
      }
    }
  }
  return null;
};

//#
//# Hole Filling Methods
//# 
geom.circleCross = function(d, r1, r2) {
  var x, y;
  x = (d * d - r2 * r2 + r1 * r1) / d / 2;
  y = Math.sqrt(r1 * r1 - x * x);
  return [x, y];
};

geom.creaseDir = function(u1, u2, a, b, eps = geom.EPS) {
  var b1, b2, x, y, z, zmag;
  b1 = Math.cos(a) + Math.cos(b);
  b2 = Math.cos(a) - Math.cos(b);
  x = geom.plus(u1, u2);
  y = geom.sub(u1, u2);
  z = geom.unit(geom.cross(y, x));
  x = geom.mul(x, b1 / geom.magsq(x));
  y = geom.mul(y, geom.magsq(y) < eps ? 0 : b2 / geom.magsq(y));
  zmag = Math.sqrt(1 - geom.magsq(x) - geom.magsq(y));
  z = geom.mul(z, zmag);
  return [x, y, z].reduce(geom.plus);
};

geom.quadSplit = function(u, p, d, t) {
  // Split from origin in direction U subject to external point P whose
  // shortest path on the surface is distance D and projecting angle is T
  if (geom.magsq(p) > d * d) {
    throw new Error("STOP! Trying to split expansive quad.");
  }
  return geom.mul(u, (d * d - geom.magsq(p)) / 2 / (d * Math.cos(t) - geom.dot(u, p)));
};
