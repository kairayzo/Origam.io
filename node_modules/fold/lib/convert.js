  /* FOLD FORMAT MANIPULATORS */
var convert, filter, geom,
  modulo = function(a, b) { return (+a % (b = +b) + b) % b; },
  hasProp = {}.hasOwnProperty;

geom = require('./geom');

filter = require('./filter');

convert = exports;

convert.edges_vertices_to_vertices_vertices_unsorted = function(fold) {
  /*
  Works for abstract structures, so NOT SORTED.
  Use sort_vertices_vertices to sort in counterclockwise order.
  */
  fold.vertices_vertices = filter.edges_vertices_to_vertices_vertices(fold);
  return fold;
};

convert.edges_vertices_to_vertices_edges_unsorted = function(fold) {
  /*
  Invert edges_vertices into vertices_edges.
  Works for abstract structures, so NOT SORTED.
  */
  fold.vertices_edges = filter.edges_vertices_to_vertices_edges(fold);
  return fold;
};

convert.edges_vertices_to_vertices_vertices_sorted = function(fold) {
  /*
  Given a FOLD object with 2D `vertices_coords` and `edges_vertices` property
  (defining edge endpoints), automatically computes the `vertices_vertices`
  property and sorts them counterclockwise by angle in the plane.
  */
  convert.edges_vertices_to_vertices_vertices_unsorted(fold);
  return convert.sort_vertices_vertices(fold);
};

convert.edges_vertices_to_vertices_edges_sorted = function(fold) {
  /*
  Given a FOLD object with 2D `vertices_coords` and `edges_vertices` property
  (defining edge endpoints), automatically computes the `vertices_edges`
  and `vertices_vertices` property and sorts them counterclockwise by angle
  in the plane.
  */
  convert.edges_vertices_to_vertices_vertices_sorted(fold);
  return convert.vertices_vertices_to_vertices_edges(fold);
};

convert.sort_vertices_vertices = function(fold) {
  var neighbors, ref, ref1, ref2, v;
  /*
  Sorts `fold.vertices_neighbords` in counterclockwise order using
  `fold.vertices_coordinates`.  2D only.
  Constructs `fold.vertices_neighbords` if absent, via
  `convert.edges_vertices_to_vertices_vertices`.
  */
  if (((ref = fold.vertices_coords) != null ? (ref1 = ref[0]) != null ? ref1.length : void 0 : void 0) !== 2) {
    throw new Error("sort_vertices_vertices: Vertex coordinates missing or not two dimensional");
  }
  if (fold.vertices_vertices == null) {
    convert.edges_vertices_to_vertices_vertices(fold);
  }
  ref2 = fold.vertices_vertices;
  for (v in ref2) {
    neighbors = ref2[v];
    geom.sortByAngle(neighbors, v, function(x) {
      return fold.vertices_coords[x];
    });
  }
  return fold;
};

convert.vertices_vertices_to_faces_vertices = function(fold) {
  /*
  Given a FOLD object with counterclockwise-sorted `vertices_vertices`
  property, constructs the implicitly defined faces, setting `faces_vertices`
  property.
  */
  var face, i, j, k, key, l, len, len1, len2, neighbors, next, ref, ref1, u, uv, v, w, x;
  next = {};
  ref = fold.vertices_vertices;
  for (v = j = 0, len = ref.length; j < len; v = ++j) {
    neighbors = ref[v];
    for (i = k = 0, len1 = neighbors.length; k < len1; i = ++k) {
      u = neighbors[i];
      next[`${u},${v}`] = neighbors[modulo(i - 1, neighbors.length)];
    }
  }
  //console.log u, v, neighbors[(i-1) %% neighbors.length]
  fold.faces_vertices = [];
  ref1 = (function() {
    var results;
    results = [];
    for (key in next) {
      results.push(key);
    }
    return results;
  })();
  //for uv, w of next
  for (l = 0, len2 = ref1.length; l < len2; l++) {
    uv = ref1[l];
    w = next[uv];
    if (w == null) {
      continue;
    }
    next[uv] = null;
    [u, v] = uv.split(',');
    u = parseInt(u);
    v = parseInt(v);
    face = [u, v];
    while (w !== face[0]) {
      if (w == null) {
        console.warn(`Confusion with face ${face}`);
        break;
      }
      face.push(w);
      [u, v] = [v, w];
      w = next[`${u},${v}`];
      next[`${u},${v}`] = null;
    }
    next[`${face[face.length - 1]},${face[0]}`] = null;
    //# Outside face is clockwise; exclude it.
    if ((w != null) && geom.polygonOrientation((function() {
      var len3, m, results;
      results = [];
      for (m = 0, len3 = face.length; m < len3; m++) {
        x = face[m];
        results.push(fold.vertices_coords[x]);
      }
      return results;
    })()) > 0) {
      //console.log face
      fold.faces_vertices.push(face);
    }
  }
  //else
  //  console.log face, 'clockwise'
  return fold;
};

convert.vertices_edges_to_faces_vertices_edges = function(fold) {
  /*
  Given a FOLD object with counterclockwise-sorted `vertices_edges` property,
  constructs the implicitly defined faces, setting both `faces_vertices`
  and `faces_edges` properties.  Handles multiple edges to the same vertex
  (unlike `FOLD.convert.vertices_vertices_to_faces_vertices`).
  */
  var e, e1, e2, edges, i, j, k, l, len, len1, len2, len3, m, neighbors, next, nexts, ref, ref1, v, vertex, vertices, x;
  next = [];
  ref = fold.vertices_edges;
  for (v = j = 0, len = ref.length; j < len; v = ++j) {
    neighbors = ref[v];
    next[v] = {};
    for (i = k = 0, len1 = neighbors.length; k < len1; i = ++k) {
      e = neighbors[i];
      next[v][e] = neighbors[modulo(i - 1, neighbors.length)];
    }
  }
  //console.log e, neighbors[(i-1) %% neighbors.length]
  fold.faces_vertices = [];
  fold.faces_edges = [];
  for (vertex = l = 0, len2 = next.length; l < len2; vertex = ++l) {
    nexts = next[vertex];
    for (e1 in nexts) {
      e2 = nexts[e1];
      if (e2 == null) {
        continue;
      }
      e1 = parseInt(e1);
      nexts[e1] = null;
      edges = [e1];
      vertices = [filter.edges_verticesIncident(fold.edges_vertices[e1], fold.edges_vertices[e2])];
      if (vertices[0] == null) {
        throw new Error(`Confusion at edges ${e1} and ${e2}`);
      }
      while (e2 !== edges[0]) {
        if (e2 == null) {
          console.warn(`Confusion with face containing edges ${edges}`);
          break;
        }
        edges.push(e2);
        ref1 = fold.edges_vertices[e2];
        for (m = 0, len3 = ref1.length; m < len3; m++) {
          v = ref1[m];
          if (v !== vertices[vertices.length - 1]) {
            vertices.push(v);
            break;
          }
        }
        e1 = e2;
        e2 = next[v][e1];
        next[v][e1] = null;
      }
      //# Move e1 to the end so that edges[0] connects vertices[0] to vertices[1]
      edges.push(edges.shift());
      //# Outside face is clockwise; exclude it.
      if ((e2 != null) && geom.polygonOrientation((function() {
        var len4, n, results;
        results = [];
        for (n = 0, len4 = vertices.length; n < len4; n++) {
          x = vertices[n];
          results.push(fold.vertices_coords[x]);
        }
        return results;
      })()) > 0) {
        //console.log vertices, edges
        fold.faces_vertices.push(vertices);
        fold.faces_edges.push(edges);
      }
    }
  }
  //else
  //  console.log face, 'clockwise'
  return fold;
};

convert.edges_vertices_to_faces_vertices = function(fold) {
  /*
  Given a FOLD object with 2D `vertices_coords` and `edges_vertices`,
  computes a counterclockwise-sorted `vertices_vertices` property and
  constructs the implicitly defined faces, setting `faces_vertices` property.
  */
  convert.edges_vertices_to_vertices_vertices_sorted(fold);
  return convert.vertices_vertices_to_faces_vertices(fold);
};

convert.edges_vertices_to_faces_vertices_edges = function(fold) {
  /*
  Given a FOLD object with 2D `vertices_coords` and `edges_vertices`,
  computes counterclockwise-sorted `vertices_vertices` and `vertices_edges`
  properties and constructs the implicitly defined faces, setting
  both `faces_vertices` and `faces_edges` property.
  */
  convert.edges_vertices_to_vertices_edges_sorted(fold);
  return convert.vertices_edges_to_faces_vertices_edges(fold);
};

convert.vertices_vertices_to_vertices_edges = function(fold) {
  /*
  Given a FOLD object with `vertices_vertices` and `edges_vertices`,
  fills in the corresponding `vertices_edges` property (preserving order).
  */
  var edge, edgeMap, i, j, len, ref, v1, v2, vertex, vertices;
  edgeMap = {};
  ref = fold.edges_vertices;
  for (edge = j = 0, len = ref.length; j < len; edge = ++j) {
    [v1, v2] = ref[edge];
    edgeMap[`${v1},${v2}`] = edge;
    edgeMap[`${v2},${v1}`] = edge;
  }
  return fold.vertices_edges = (function() {
    var k, len1, ref1, results;
    ref1 = fold.vertices_vertices;
    results = [];
    for (vertex = k = 0, len1 = ref1.length; k < len1; vertex = ++k) {
      vertices = ref1[vertex];
      results.push((function() {
        var l, ref2, results1;
        results1 = [];
        for (i = l = 0, ref2 = vertices.length; (0 <= ref2 ? l < ref2 : l > ref2); i = 0 <= ref2 ? ++l : --l) {
          results1.push(edgeMap[`${vertex},${vertices[i]}`]);
        }
        return results1;
      })());
    }
    return results;
  })();
};

convert.faces_vertices_to_faces_edges = function(fold) {
  /*
  Given a FOLD object with `faces_vertices` and `edges_vertices`,
  fills in the corresponding `faces_edges` property (preserving order).
  */
  var edge, edgeMap, face, i, j, len, ref, v1, v2, vertices;
  edgeMap = {};
  ref = fold.edges_vertices;
  for (edge = j = 0, len = ref.length; j < len; edge = ++j) {
    [v1, v2] = ref[edge];
    edgeMap[`${v1},${v2}`] = edge;
    edgeMap[`${v2},${v1}`] = edge;
  }
  return fold.faces_edges = (function() {
    var k, len1, ref1, results;
    ref1 = fold.faces_vertices;
    results = [];
    for (face = k = 0, len1 = ref1.length; k < len1; face = ++k) {
      vertices = ref1[face];
      results.push((function() {
        var l, ref2, results1;
        results1 = [];
        for (i = l = 0, ref2 = vertices.length; (0 <= ref2 ? l < ref2 : l > ref2); i = 0 <= ref2 ? ++l : --l) {
          results1.push(edgeMap[`${vertices[i]},${vertices[(i + 1) % vertices.length]}`]);
        }
        return results1;
      })());
    }
    return results;
  })();
};

convert.faces_vertices_to_edges = function(mesh) {
  var edge, edgeMap, face, i, key, ref, v1, v2, vertices;
  /*
  Given a FOLD object with just `faces_vertices`, automatically fills in
  `edges_vertices`, `edges_faces`, `faces_edges`, and `edges_assignment`
  (indicating which edges are boundary with 'B').
  This code currently assumes an orientable manifold, and uses nulls to
  represent missing neighbor faces in `edges_faces` (for boundary edges).
  */
  mesh.edges_vertices = [];
  mesh.edges_faces = [];
  mesh.faces_edges = [];
  mesh.edges_assignment = [];
  edgeMap = {};
  ref = mesh.faces_vertices;
  for (face in ref) {
    vertices = ref[face];
    face = parseInt(face);
    mesh.faces_edges.push((function() {
      var j, len, results;
      results = [];
      for (i = j = 0, len = vertices.length; j < len; i = ++j) {
        v1 = vertices[i];
        v1 = parseInt(v1);
        v2 = vertices[(i + 1) % vertices.length];
        if (v1 <= v2) {
          key = `${v1},${v2}`;
        } else {
          key = `${v2},${v1}`;
        }
        if (key in edgeMap) {
          edge = edgeMap[key];
          // Second instance of edge means not on boundary
          mesh.edges_assignment[edge] = null;
        } else {
          edge = edgeMap[key] = mesh.edges_vertices.length;
          if (v1 <= v2) {
            mesh.edges_vertices.push([v1, v2]);
          } else {
            mesh.edges_vertices.push([v2, v1]);
          }
          mesh.edges_faces.push([null, null]);
          // First instance of edge might be on boundary
          mesh.edges_assignment.push('B');
        }
        if (v1 <= v2) {
          mesh.edges_faces[edge][0] = face;
        } else {
          mesh.edges_faces[edge][1] = face;
        }
        results.push(edge);
      }
      return results;
    })());
  }
  return mesh;
};

convert.edges_vertices_to_edges_faces_edges = function(fold) {
  var edge, edgeMap, face, i, orient, ref, ref1, v1, v2, vertices;
  /*
  Given a `fold` object with `edges_vertices` and `faces_vertices`,
  fills in `faces_edges` and `edges_vertices`.
  */
  fold.edges_faces = (function() {
    var j, ref, results;
    results = [];
    for (edge = j = 0, ref = fold.edges_vertices.length; (0 <= ref ? j < ref : j > ref); edge = 0 <= ref ? ++j : --j) {
      results.push([null, null]);
    }
    return results;
  })();
  edgeMap = {};
  ref = fold.edges_vertices;
  for (edge in ref) {
    vertices = ref[edge];
    if (!(vertices != null)) {
      continue;
    }
    edge = parseInt(edge);
    edgeMap[`${vertices[0]},${vertices[1]}`] = [
      edge,
      0 // forward
    ];
    edgeMap[`${vertices[1]},${vertices[0]}`] = [
      edge,
      1 // backward
    ];
  }
  ref1 = fold.faces_vertices;
  for (face in ref1) {
    vertices = ref1[face];
    face = parseInt(face);
    fold.faces_edges[face] = (function() {
      var j, len, results;
      results = [];
      for (i = j = 0, len = vertices.length; j < len; i = ++j) {
        v1 = vertices[i];
        v2 = vertices[(i + 1) % vertices.length];
        [edge, orient] = edgeMap[`${v1},${v2}`];
        fold.edges_faces[edge][orient] = face;
        results.push(edge);
      }
      return results;
    })();
  }
  return fold;
};

convert.flatFoldedGeometry = function(fold, rootFace = 0) {
  var base, edge, edge2, face, face2, i, j, k, l, len, len1, len2, len3, len4, len5, len6, len7, level, m, mapped, maxError, n, nextLevel, o, orientation, p, q, ref, ref1, ref2, ref3, ref4, ref5, ref6, row, transform, vertex, vertex2;
  /*
  Assuming `fold` is a locally flat foldable crease pattern in the xy plane,
  sets `fold.vertices_flatFoldCoords` to give the flat-folded geometry
  as determined by repeated reflection relative to `rootFace`; sets
  `fold.faces_flatFoldTransform` transformation matrix mapping each face's
  unfolded --> folded geometry; and sets `fold.faces_flatFoldOrientation` to
  +1 or -1 to indicate whether each folded face matches its original
  orientation or is upside-down (so is oriented clockwise in 2D).

  Requires `fold` to have `vertices_coords` and `edges_vertices`;
  `edges_faces` and `faces_edges` will be created if they do not exist.

  Returns the maximum displacement error from closure constraints (multiple
  mappings of the same vertices, or multiple transformations of the same face).
  */
  if ((fold.vertices_coords != null) && (fold.edges_vertices != null) && !((fold.edges_faces != null) && (fold.faces_edges != null))) {
    convert.edges_vertices_to_edges_faces_edges(fold);
  }
  maxError = 0;
  level = [rootFace];
  fold.faces_flatFoldTransform = (function() {
    var j, ref, results;
    results = [];
    for (face = j = 0, ref = fold.faces_edges.length; (0 <= ref ? j < ref : j > ref); face = 0 <= ref ? ++j : --j) {
      results.push(null);
    }
    return results;
  })();
  fold.faces_flatFoldTransform[rootFace] = [
    [1,
    0,
    0],
    [
      0,
      1,
      0 // identity
    ]
  ];
  fold.faces_flatFoldOrientation = (function() {
    var j, ref, results;
    results = [];
    for (face = j = 0, ref = fold.faces_edges.length; (0 <= ref ? j < ref : j > ref); face = 0 <= ref ? ++j : --j) {
      results.push(null);
    }
    return results;
  })();
  fold.faces_flatFoldOrientation[rootFace] = +1;
  fold.vertices_flatFoldCoords = (function() {
    var j, ref, results;
    results = [];
    for (vertex = j = 0, ref = fold.vertices_coords.length; (0 <= ref ? j < ref : j > ref); vertex = 0 <= ref ? ++j : --j) {
      results.push(null);
    }
    return results;
  })();
  ref = fold.faces_edges[rootFace];
  // Use fold.faces_edges -> fold.edges_vertices, which are both needed below,
  // in case fold.faces_vertices isn't defined.
  for (j = 0, len = ref.length; j < len; j++) {
    edge = ref[j];
    ref1 = fold.edges_vertices[edge];
    for (k = 0, len1 = ref1.length; k < len1; k++) {
      vertex = ref1[k];
      if ((base = fold.vertices_flatFoldCoords)[vertex] == null) {
        base[vertex] = fold.vertices_coords[vertex].slice(0);
      }
    }
  }
  while (level.length) {
    nextLevel = [];
    for (l = 0, len2 = level.length; l < len2; l++) {
      face = level[l];
      orientation = -fold.faces_flatFoldOrientation[face];
      ref2 = fold.faces_edges[face];
      for (m = 0, len3 = ref2.length; m < len3; m++) {
        edge = ref2[m];
        ref3 = fold.edges_faces[edge];
        for (n = 0, len4 = ref3.length; n < len4; n++) {
          face2 = ref3[n];
          if (!((face2 != null) && face2 !== face)) {
            continue;
          }
          transform = geom.matrixMatrix(fold.faces_flatFoldTransform[face], geom.matrixReflectLine(...((function() {
            var len5, o, ref4, results;
            ref4 = fold.edges_vertices[edge];
            results = [];
            for (o = 0, len5 = ref4.length; o < len5; o++) {
              vertex = ref4[o];
              results.push(fold.vertices_coords[vertex]);
            }
            return results;
          })())));
          if (fold.faces_flatFoldTransform[face2] != null) {
            ref4 = fold.faces_flatFoldTransform[face2];
            for (i = o = 0, len5 = ref4.length; o < len5; i = ++o) {
              row = ref4[i];
              maxError = Math.max(maxError, geom.dist(row, transform[i]));
            }
            if (orientation !== fold.faces_flatFoldOrientation[face2]) {
              maxError = Math.max(1, maxError);
            }
          } else {
            fold.faces_flatFoldTransform[face2] = transform;
            fold.faces_flatFoldOrientation[face2] = orientation;
            ref5 = fold.faces_edges[face2];
            for (p = 0, len6 = ref5.length; p < len6; p++) {
              edge2 = ref5[p];
              ref6 = fold.edges_vertices[edge2];
              for (q = 0, len7 = ref6.length; q < len7; q++) {
                vertex2 = ref6[q];
                mapped = geom.matrixVector(transform, fold.vertices_coords[vertex2]);
                if (fold.vertices_flatFoldCoords[vertex2] != null) {
                  maxError = Math.max(maxError, geom.dist(fold.vertices_flatFoldCoords[vertex2], mapped));
                } else {
                  fold.vertices_flatFoldCoords[vertex2] = mapped;
                }
              }
            }
            nextLevel.push(face2);
          }
        }
      }
    }
    level = nextLevel;
  }
  return maxError;
};

convert.deepCopy = function(fold) {
  var copy, item, j, key, len, ref, results, value;
  //# Given a FOLD object, make a copy that shares no pointers with the original.
  if ((ref = typeof fold) === 'number' || ref === 'string' || ref === 'boolean') {
    return fold;
  } else if (Array.isArray(fold)) {
    results = [];
    for (j = 0, len = fold.length; j < len; j++) {
      item = fold[j];
      results.push(convert.deepCopy(item)); // Object
    }
    return results;
  } else {
    copy = {};
    for (key in fold) {
      if (!hasProp.call(fold, key)) continue;
      value = fold[key];
      copy[key] = convert.deepCopy(value);
    }
    return copy;
  }
};

convert.toJSON = function(fold) {
  var key, obj, value;
  //# Convert FOLD object into a nicely formatted JSON string.
  return "{\n" + ((function() {
    var results;
    results = [];
    for (key in fold) {
      value = fold[key];
      results.push(`  ${JSON.stringify(key)}: ` + (Array.isArray(value) ? "[\n" + ((function() {
        var j, len, results1;
        results1 = [];
        for (j = 0, len = value.length; j < len; j++) {
          obj = value[j];
          results1.push(`    ${JSON.stringify(obj)}`);
        }
        return results1;
      })()).join(',\n') + "\n  ]" : JSON.stringify(value)));
    }
    return results;
  })()).join(',\n') + "\n}\n";
};

convert.extensions = {};

convert.converters = {};

convert.getConverter = function(fromExt, toExt) {
  if (fromExt === toExt) {
    return function(x) {
      return x;
    };
  } else {
    return convert.converters[`${fromExt}${toExt}`];
  }
};

convert.setConverter = function(fromExt, toExt, converter) {
  convert.extensions[fromExt] = true;
  convert.extensions[toExt] = true;
  return convert.converters[`${fromExt}${toExt}`] = converter;
};

convert.convertFromTo = function(data, fromExt, toExt) {
  var converter;
  if (fromExt[0] !== '.') {
    fromExt = `.${fromExt}`;
  }
  if (toExt[0] !== '.') {
    toExt = `.${toExt}`;
  }
  converter = convert.getConverter(fromExt, toExt);
  if (converter == null) {
    if (fromExt === toExt) {
      return data;
    }
    throw new Error(`No converter from ${fromExt} to ${toExt}`);
  }
  return converter(data);
};

convert.convertFrom = function(data, fromExt) {
  return convert.convertFromTo(data, fromExt, '.fold');
};

convert.convertTo = function(data, toExt) {
  return convert.convertFromTo(data, '.fold', toExt);
};

convert.oripa = require('./oripa');
